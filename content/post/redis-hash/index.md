---
title: Redis Hash 结构的底层实现
description: Redis 的 Hash 和 Java 的 HashMap 虽然都提供了键值对的存储功能，但它们的底层实现和用途有显著差异（主要记录自己最近面试遇到的问题
slug: redis-hash
date: 2024-12-24 00:00:00+0000
categories:
  - tech
tags:
  - Redis
draft: false
---
# Java HashMap 和 Redis Hash 的区别

• **Redis 的 hash**:

• Redis 的 hash 是基于自定义的哈希表实现，支持高效的键值对操作。

• 其内部实现利用了 **dict** 数据结构，具体是通过动态哈希表和链地址法处理冲突。

• Redis 的 hash 可以存储较大规模的数据，但一般会限制在单个键值对（Field 和 Value）的大小范围内。

• **Java 的 HashMap**:

• Java 的 HashMap 是基于 **数组 + 链表 + 红黑树** 实现的哈希表。

• 当链表长度超过阈值（默认 8）时，会将链表转换为红黑树以优化性能。

在 Redis 中，dict 是 Redis 内部用来实现哈希表的一种核心数据结构。它为 Redis 的很多功能提供了基础支持，包括键值存储、集合和哈希类型等。

## dict

• dict 是 Redis 的哈希表实现。

• 它的主要目的是提供快速的键值对存储和检索。

• 由两个哈希表组成，用于支持渐进式 rehash 操作（扩容或缩容时逐步迁移数据）。

### 结构组成
Redis 的 dict 主要由以下几个部分组成：
1. dict 结构
	dict 是一个封装了哈希表的结构，它包含两个 dictEntry 数组和一些辅助信息。定义如下：
```c
typedef struct dict {
    dictType *type;          // 类型特定函数（如计算哈希值、键比较等）
    void *privdata;          // 私有数据指针，供用户使用
    dictht ht[2];            // 两个哈希表，ht[0] 和 ht[1]
    long rehashidx;          // rehash 索引，-1 表示未进行 rehash
    unsigned long iterators; // 当前运行的安全迭代器数量
} dict;
```
2. dictht 结构
	dictht 是具体的哈希表结构，定义如下：
```c
typedef struct dictht {
    dictEntry **table;       // 哈希表数组
    unsigned long size;      // 哈希表大小
    unsigned long sizemask;  // 用于计算索引的掩码 (size - 1)
    unsigned long used;      // 已使用的节点数量
} dictht;
```

- table 是一个指针数组，每个元素指向一个 dictEntry 链表的头结点。
- sizemask 和 size 用于快速计算哈希值的存储位置。

3. dictEntry 结构
	dictEntry 是存储具体键值对的结构：
```c
typedef struct dictEntry {
    void *key;               // 键
    union {
        void *val;           // 值（通用指针）
        uint64_t u64;        // 64 位无符号整数值
        int64_t s64;         // 64 位有符号整数值
        double d;            // 浮点值
    } v;                     // 值
    struct dictEntry *next;  // 指向下一个节点，用于处理哈希冲突（链表法）
} dictEntry;
```

#### dict的特性

1. **双哈希表支持**:
	-  Redis 的 dict 拥有两个哈希表（ht[0] 和 ht[1]），正常情况下只使用 ht[0]。
	- 在扩容或缩容时，ht[1] 会被用来暂存新数据，然后逐步将数据从 ht[0] 迁移到 ht[1]。

2. **渐进式 Rehash**:
	- 扩容或缩容时，Redis 不会一次性完成哈希表的重建。
	- 每次对哈希表进行读/写操作时，Redis 会将 ht[0] 中的一部分数据迁移到 ht[1]，从而避免性能抖动。

3. **动态调整大小**
	- Redis 会根据哈希表的负载因子（used / size）动态调整哈希表的大小：
	- 当负载因子超过 1（即元素数量大于桶数量）时，触发扩容。
	- 当 Redis 处于高内存压力时（maxmemory 限制），负载因子可以放宽到 5。

4. **冲突解决**:
	- 使用链地址法解决哈希冲突。
	- 同一索引的多个键值对通过 dictEntry 链表连接。
## Redis Dict 和 Java Hash表有何不同

### 数据结构
**Redis Dict**
- **数组**：哈希槽的核心存储，每个槽位可以指向一个链表。初始大小通常根据实际数据动态调整，避免空间浪费。
-  **链表**：用于处理哈希冲突，存储冲突的键值对。Redis 的链表比较简单，只是一个线性链表，没有复杂的数据结构。
- **渐进式 Rehash**：
	-  Redis 通过维护两张哈希表（ht[0] 和 ht[1]）来实现动态扩容或缩容。扩容时避免一次性拷贝，通过增量方式分批迁移数据。
	-  数据迁移是逐步完成的，不会阻塞服务。
	-  优势：不会造成显著的性能抖动。
	-  劣势：Rehash 完成前需要维护两张哈希表，稍微增加了内存开销。
  
**Java HashMap**
- **数组**：存储哈希桶，每个桶可以指向一个链表或树结构。
- **链表**：用于解决冲突，链表长度超过阈值后会转换为红黑树。
	- **链表转红黑树**：
		-  在链表长度超过 8 时，链表自动转化为红黑树，降低最坏情况下的查找复杂度（从 O(n) 降到 O(log n)）。
		-  当节点数量少于 6 时，会回退为链表。
		-  优势：极大优化了高冲突情况下的性能。
		-  劣势：引入红黑树增加了实现复杂性。
- **直接扩容**：
	-  HashMap 在负载因子达到阈值时（默认 0.75）触发扩容，直接分配新的数组，将所有数据重新哈希并迁移。会导致明显的性能开销，尤其在存储大量数据时。

**总结**

| 特性           | Redis Dict          | Java HashMap                 |
|----------------|---------------------|------------------------------|
| 核心结构       | 数组 + 链表         | 数组 + 链表/红黑树          |
| 扩容机制       | 渐进式 Rehash       | 直接扩容，性能可能抖动       |
| 冲突处理       | 链地址法（链表）     | 链地址法 + 链表转树          |
| 并发支持       | 单线程操作          | 线程不安全，多线程需额外支持 |
| 实现复杂度     | 简单，轻量化        | 较复杂，支持更多功能         |
| 适用场景       | 高性能内存数据库    | 通用本地存储                |
