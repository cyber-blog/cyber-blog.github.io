---
title: Mysql 查询流程
description: Mysql 查询流程，包括索引覆盖，索引下推，最左原则，回表等
date: 2023-10-24 00:00:00+0000
categories:
  - tech
tags:
  - MYSQL
draft: false
---
# **MySQL 索引结构与执行流程：从 B+ 树到联合索引与索引下推全解析**

  

本篇文章从 MySQL 为什么选择 B+ 树索引开始，逐步引出联合索引的最左匹配原则、索引下推（ICP）、回表机制和覆盖索引等关键执行细节，帮助你从结构、原理到实际执行路径深入理解索引背后的逻辑。

---

## **一、为什么 MySQL 选择 B+ 树而非 B 树？**

MySQL 中使用最广泛的 InnoDB 存储引擎采用 **B+ 树** 作为索引结构，这种选择并非偶然。
### **1. B 树 vs B+ 树 的结构差异**

|**特性**|**B 树**|**B+ 树**|
|---|---|---|
|数据存储|所有节点都存数据|仅叶子节点存数据，内部节点只存键|
|查询路径|查询可能在中间节点结束|查询必须走到叶子节点|
|范围扫描|需要中序遍历整棵树|叶子节点通过链表串联，天然支持范围查询|

### **2. 为什么 B+ 树更适合数据库索引？**

- **磁盘访问效率更高**：非叶子节点更小，内存缓存命中率更高，减少磁盘 IO；
    
- **范围查询更高效**：链表串联叶子节点，直接顺序扫描即可；
    
- **结构稳定、查询均衡**：所有查找都走到叶子节点，路径统一，优化更容易；
    
- **排序与全表扫描友好**：天然有序，支持快速 ORDER BY；
    

  

📌 **总结：B+ 树对磁盘 I/O、范围查、缓存友好，全面优于 B 树，是关系型数据库的首选。**

---

## **二、联合索引与最左匹配原则**

### **1. 什么是联合索引？**

联合索引是将多个字段作为一个整体创建的复合索引，例如：

```
CREATE INDEX idx_abc ON user(a, b, c);
```

在使用联合索引 (a, b, c) 时，会把每一行的 a、b、c 作为组合键 (a, b, c) 排序成一棵 B+ 树，其比较顺序就是字典序。它在 B+ 树的叶子节点上，按照 a -> b -> c 的顺序排列。

B+树索引示例
```
                     Root Node
                 +-----------------+
                 |   (2,1,1)       |
                 +-----------------+
                    /          \
                   /            \
      +------------------+   +------------------+      ← 中间节点
      |   (1,2,1)        |   |   (2,2,1)        |
      +------------------+   +------------------+
          /      \              /       \
         /        \            /         \
   Leaf1          Leaf2     Leaf3       Leaf4      ← 叶子节点（有序链表）
+----------+   +----------+ +----------+ +----------+
|1,1,1     | → |1,1,2     | →|1,2,1     | →|2,1,1     |
+----------+   +----------+ +----------+ +----------+
                                                   ↓
                                             +----------+
                                             |2,2,1     | → (尾部 null)
                                             +----------+
```

### **2. 为什么要遵循最左匹配原则？**

只有**从最左侧字段开始连续使用**，索引才能被利用。例如：

| **WHERE 条件**          | **是否命中 idx_abc** |
| --------------------- | ---------------- |
| WHERE a = 1           | ✅ 使用 a           |
| WHERE a = 1 AND b = 2 | ✅ 使用 a、b         |
| WHERE b = 2           | ❌ 不使用联合索引        |
| WHERE a = 1 AND c = 3 | ✅ 使用 a，但 c 不触发   |

> 联合索引中的比较（如 < (2,1,1)）是基于联合键的**字典序**，而最左前缀原则则是限制你**必须从前往后匹配字段**，否则 B+ 树无法正确判断搜索路径。

---

## **三、联合索引查询执行流程（含回表、索引下推、覆盖索引）**

我们通过一个实际查询来讲解完整的执行流程：

  

### **1. 表结构与查询示例**

```
CREATE TABLE user (
  id INT PRIMARY KEY,
  a INT,
  b INT,
  c INT,
  d VARCHAR(100),
  KEY idx_abc (a, b, c)
);

SELECT c FROM user WHERE a = 1 AND b = 2 AND c > 3;
```

### **2. 执行流程（含 Server 层与 InnoDB 层分工）**

```
【1】客户端发送 SQL 查询：
     SELECT d FROM t WHERE a = 1 AND c = 2;

【2】Server 层：
  ├─ 解析 SQL，生成执行计划
  ├─ 确认可以使用联合索引 idx_a_b_c（a 是最左字段）
  ├─ 判断：c 不满足最左前缀 → 不能用于定位
  └─ 但是 ✅ 可以使用 Index Condition Pushdown（ICP）
         ↓
【3】Server 层下发执行计划 + 下推过滤条件 (c=2) 到 InnoDB
         ↓
【4】InnoDB 二级索引扫描 idx_a_b_c：
  ├─ 根据 a=1 扫描对应索引区间
  ├─ 对每一个记录，**在扫描索引的同时检查 c=2**
  └─ ✅ 满足 c=2 的主键 id 被保留，其他跳过（减少回表）
         ↓
【5】返回匹配的主键 id（如 id=123、id=456）给 Server
         ↓
【6】Server 层判断：
  └─ 字段 d 不在索引中 ❌ → 必须回表
         ↓
【7】InnoDB 根据主键 ID 回表：
  ├─ 检查主键页是否在 Buffer Pool（缓存）
  │     └─ ✅ 在内存 → 直接读取
  │     └─ ❌ 不在内存 → 触发磁盘 IO
  └─ 返回完整行数据（含 d 字段）
         ↓
【8】Server 层组装最终结果，返回给客户端
```

### **3. 术语解析**

- ✅ **索引下推（ICP）**：将 c > 3 的判断提前到 InnoDB 层，在遍历索引时就过滤不符合的行，避免大量无效回表；
    
- ✅ **覆盖索引**：查询字段 c 已经在索引 idx_abc 中，直接从叶子节点读取，无需访问主键页（聚簇索引），提高效率；
    
- ❌ **回表**：如果 SELECT 中包含非索引字段（如 d），则需根据主键 id 再去聚簇索引中查找整行数据，增加开销；
    

---

## **四、Hash 索引对比补充：适合极端等值查询**

  

### **1. Hash 索引特点（多用于 Memory 引擎）**

|**特性**|**Hash 索引**|**B+ 树索引**|
|---|---|---|
|查找效率|✅ 等值查询最快|✅ 稍慢但功能更全|
|范围查询|❌ 不支持|✅ 支持|
|排序|❌ 不支持|✅ 支持（叶子链表）|
|支持引擎|仅 Memory，或自适应哈希|InnoDB、MyISAM、Memory 等|

### **2. InnoDB 的自适应哈希索引（AHI）**

InnoDB 会自动监控某些 B+ 树热点页，自动为其建立 Hash 索引以优化等值查询，这对开发者透明、不可控制。

---

### **五、InnoDB 无主键表时会如何查询**

1. **自动生成隐藏主键**：
    
    若表无显式主键或唯一非空索引，InnoDB 会自动添加一个 **6字节隐藏 RowID**，作为聚簇索引的 key。
    
2. **二级索引指向 RowID**：
    
    所有二级索引将指向这个隐藏 RowID，而不是显式主键。
    
3. **查询过程与回表**：
    
    - 查询时先通过二级索引查出 RowID；
        
    - 然后根据 RowID 去聚簇索引中“回表”获取整行数据；
        
    - 返回所需字段。
        
    
4. **性能与维护影响**：
    
    - 无法控制 RowID 排序与结构；
        
    - 查询效率和调优难度高于有主键表；
        
    - 不利于数据管理和故障排查。

六、Mysql 深分页的查询优化总结



## **五、总结与优化建议**

- ✅ B+ 树索引是数据库查询的核心结构，范围查、排序查都依赖它；
    
- ✅ 联合索引需注意“最左前缀”匹配，字段顺序设计极关键；
    
- ✅ ICP（索引下推）可减少回表成本，提高查询效率；
    
- ✅ 覆盖索引是查询最优形态，能避免访问主键页；
    
- ✅ Hash 索引虽快，但仅适合极简等值查找场景。
    

📌 **优化索引设计的核心策略：**

> 通过合理设计联合索引顺序 + 使用覆盖索引 + 启用 ICP

从根源上减少回表次数，才是提升 MySQL 查询性能的核心。

