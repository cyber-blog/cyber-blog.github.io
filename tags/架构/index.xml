<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>架构 on 仿生人会梦见电子羊吗？</title><link>https://cyber-blog.github.io/tags/%E6%9E%B6%E6%9E%84/</link><description>Recent content in 架构 on 仿生人会梦见电子羊吗？</description><generator>Hugo -- gohugo.io</generator><language>zh-ch</language><managingEditor>majiang213@foxmail.com (majiang)</managingEditor><webMaster>majiang213@foxmail.com (majiang)</webMaster><lastBuildDate>Tue, 08 Jul 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://cyber-blog.github.io/tags/%E6%9E%B6%E6%9E%84/index.xml" rel="self" type="application/rss+xml"/><item><title>一致性哈希的简单介绍</title><link>https://cyber-blog.github.io/p/consistent-hash/</link><pubDate>Tue, 08 Jul 2025 00:00:00 +0000</pubDate><author>majiang213@foxmail.com (majiang)</author><guid>https://cyber-blog.github.io/p/consistent-hash/</guid><description>&lt;p>在分布式系统的设计与实现中，如何有效地管理数据分布、处理节点变动，并保持系统的高可用性与负载均衡，一直是一个核心挑战。随着云计算和微服务架构的广泛应用，传统的哈希方法已显得力不从心，特别是在节点动态变动的情况下。&lt;strong>一致性哈希（Consistent Hashing）算法&lt;/strong>作为一种创新的解决方案，因其显著的优势而被广泛应用于分布式缓存、负载均衡、分布式存储等场景中。&lt;/p>
&lt;p>本文将深度解析一致性哈希算法的工作原理、应用优势与局限性，并探讨它在实际应用中的挑战及潜在的优化方向。&lt;/p>
&lt;hr>
&lt;h2 id="一哈希算法的传统挑战与一致性哈希的提出">&lt;strong>一、哈希算法的传统挑战与一致性哈希的提出&lt;/strong>
&lt;/h2>&lt;h3 id="11-传统哈希算法的局限性">&lt;strong>1.1 传统哈希算法的局限性&lt;/strong>
&lt;/h3>&lt;p>哈希算法在分布式系统中的主要目的是将数据均匀地分配到多个节点上，从而保证数据的高可用性与系统的负载均衡。然而，传统哈希算法在处理节点变动时存在几个显著的缺点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>节点变动时的数据重分配&lt;/strong>：在传统哈希算法中，每次节点增加或减少时，数据需要重新分配。假设我们有N个节点，每个节点承载M个数据，节点数量变化时，可能需要重新映射大量数据。这种数据迁移不仅增加了系统的负担，还会导致性能下降。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>负载不均问题&lt;/strong>：节点的负载不均可能导致某些节点超负荷运行，而其他节点则空闲，影响系统的响应速度和稳定性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>节点动态性问题&lt;/strong>：分布式系统中，节点的数量通常是动态的，如何高效地处理节点的增删，成为了分布式架构中的一个挑战。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="12-一致性哈希的提出">&lt;strong>1.2 一致性哈希的提出&lt;/strong>
&lt;/h3>&lt;p>为了应对这些挑战，&lt;strong>David Karger&lt;/strong> 等人于1997年提出了一致性哈希算法。该算法旨在通过减少节点变动时的数据迁移，降低系统的负担，实现平滑的数据迁移和高效的负载均衡。其核心思想是将整个哈希空间映射为一个环，每个节点和数据项都通过哈希函数映射到环上，数据项总是被存储到第一个顺时针方向上哈希值大于或等于数据项哈希值的节点上。&lt;/p>
&lt;hr>
&lt;h2 id="二一致性哈希算法的核心原理">&lt;strong>二、一致性哈希算法的核心原理&lt;/strong>
&lt;/h2>&lt;p>一致性哈希的核心思想通过哈希环来实现节点与数据的映射，从而减少节点增减时的数据迁移量。&lt;/p>
&lt;h3 id="21-哈希环与节点分布">&lt;strong>2.1 哈希环与节点分布&lt;/strong>
&lt;/h3>&lt;p>一致性哈希的工作原理基于一个哈希环，将哈希空间视为一个大环（例如0到2^32-1的整数区间）。每个节点和数据项都通过哈希函数映射到这个环上。数据项会被存储在哈希值大于或等于数据项哈希值的第一个节点上。节点的哈希值可以通过hash(node)计算得到，而数据项的哈希值则通过hash(data)来计算。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>节点映射&lt;/strong>：每个节点被映射到哈希环上一个位置，假设节点的哈希值为hash(node)，则节点在哈希环上的位置就是hash(node) % 2^32。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>数据映射&lt;/strong>：每个数据项（例如用户请求的key）会通过hash(data)计算其哈希值，然后顺时针方向找到第一个哈希值大于或等于该数据项哈希值的节点，将数据存储到该节点。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="22-节点增减的处理">&lt;strong>2.2 节点增减的处理&lt;/strong>
&lt;/h3>&lt;p>一致性哈希的优势之一就是对节点增删的高效处理。传统哈希方法在节点变动时需要重新分配所有数据，但一致性哈希只会影响与新增或删除节点相邻的数据项。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>节点增加&lt;/strong>：当新增一个节点时，只有距离其哈希值最近的数据项会被迁移到该节点。其他节点上的数据不受影响，极大地减少了数据的迁移量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>节点删除&lt;/strong>：当一个节点被删除时，它所存储的数据会由顺时针方向上的下一个节点接管，迁移的数据量也被限制在相邻节点之间。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="23-虚拟节点的引入">&lt;strong>2.3 虚拟节点的引入&lt;/strong>
&lt;/h3>&lt;p>为了避免哈希环上节点分布不均带来的负载不均问题，一致性哈希引入了虚拟节点的概念。每个物理节点可以映射到多个虚拟节点，这样即使物理节点数量较少，虚拟节点的数量足够多，依然能保证数据的均匀分布。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>虚拟节点映射&lt;/strong>：每个物理节点通过哈希函数生成多个虚拟节点，每个虚拟节点占有哈希环上的一个位置。虚拟节点可以帮助平衡负载，避免某些节点因为物理节点数量较少而导致负载不均。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="三一致性哈希的优缺点">&lt;strong>三、一致性哈希的优缺点&lt;/strong>
&lt;/h2>&lt;h3 id="31-优点">&lt;strong>3.1 优点&lt;/strong>
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>&lt;strong>减少数据迁移&lt;/strong>：一致性哈希通过节点的局部调整，显著减少了数据迁移量。例如，新增节点时，只需迁移一小部分数据，避免了全量数据迁移的开销。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>负载均衡&lt;/strong>：虚拟节点的引入使得数据的分布更加均匀，能够有效解决节点负载不均的问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>高扩展性和容错性&lt;/strong>：一致性哈希能够平滑处理节点的增减，使得系统具有很高的扩展性。在节点失败时，数据的丢失范围也较小，具备较强的容错能力。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="32-缺点">&lt;strong>3.2 缺点&lt;/strong>
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>&lt;strong>虚拟节点的管理复杂性&lt;/strong>：尽管虚拟节点在负载均衡方面发挥了重要作用，但它们的管理需要额外的计算与存储。特别是在节点频繁变化时，如何合理分配和管理虚拟节点成为了一个挑战。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>数据热点问题&lt;/strong>：尽管一致性哈希减少了数据的迁移，但在某些情况下，特定节点的负载可能仍然过高，导致出现热点问题。这个问题可以通过更加智能的虚拟节点管理来解决，但它仍然是一个需要优化的方向。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="四一致性哈希与其他算法的比较">&lt;strong>四、一致性哈希与其他算法的比较&lt;/strong>
&lt;/h2>&lt;p>一致性哈希算法相较于其他常见的哈希或负载均衡算法，在节点变动处理上的效率显著更高。以下是几种常见哈希算法的比较：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>随机哈希&lt;/strong>：随机哈希将数据随机分配到多个节点上，无法保证数据的均匀分布，并且在节点增减时会产生大量数据迁移。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>目标哈希&lt;/strong>：目标哈希通过节点与数据之间的目标值映射来进行负载均衡。尽管其在节点变动时的表现不如一致性哈希高效，但它在一些场景下仍有应用价值。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>一致性哈希通过哈希环和虚拟节点的引入，优化了数据迁移问题，实现了更高效的数据分配和负载均衡。&lt;/p>
&lt;hr>
&lt;h2 id="五一致性哈希的实际应用案例">&lt;strong>五、一致性哈希的实际应用案例&lt;/strong>
&lt;/h2>&lt;h3 id="51-分布式缓存">&lt;strong>5.1 分布式缓存&lt;/strong>
&lt;/h3>&lt;p>在分布式缓存系统中，一致性哈希被广泛应用。例如，&lt;strong>Memcached&lt;/strong> 和 &lt;strong>Redis&lt;/strong> 等缓存系统使用一致性哈希来优化节点增减时的数据迁移。当缓存节点的数量发生变化时，仅需迁移相邻的数据，而非全量迁移，极大地降低了成本。&lt;/p>
&lt;h3 id="52-分布式存储与数据库">&lt;strong>5.2 分布式存储与数据库&lt;/strong>
&lt;/h3>&lt;p>分布式数据库如&lt;strong>Amazon DynamoDB&lt;/strong> 和 &lt;strong>Cassandra&lt;/strong> 使用一致性哈希来实现高效的分布式存储。通过一致性哈希，数据分布可以平滑地处理节点的增删，减少了扩展过程中的数据迁移和负载不均问题。&lt;/p>
&lt;h3 id="53-负载均衡">&lt;strong>5.3 负载均衡&lt;/strong>
&lt;/h3>&lt;p>在&lt;strong>Nginx&lt;/strong> 和 &lt;strong>HAProxy&lt;/strong> 等负载均衡器中，一致性哈希通过客户端请求特征（如IP地址）实现请求分配。这样，当新增后端服务器时，仅会影响与新节点相邻的请求，减少了重新分配的开销。&lt;/p>
&lt;hr>
&lt;h2 id="六未来发展与优化">&lt;strong>六、未来发展与优化&lt;/strong>
&lt;/h2>&lt;p>尽管一致性哈希已经在多个领域取得了成功，但仍然有进一步的优化空间。以下是几个潜在的优化方向：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>虚拟节点的自适应管理&lt;/strong>：可以引入自适应算法，根据节点负载和变动情况动态调整虚拟节点的数量与分布。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>混合算法&lt;/strong>：结合一致性哈希与其他负载均衡算法（如目标哈希、最小负载等），通过智能调度进一步提升数据分布的均衡性和系统的效率。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="七总结">&lt;strong>七、总结&lt;/strong>
&lt;/h2>&lt;p>一致性哈希算法为分布式系统提供了一个高效、低成本的数据分配和负载均衡解决方案。通过哈希环和虚拟节点的创新设计，它能够在节点增减时显著减少数据迁移，保证系统的高可用性和扩展性。尽管存在虚拟节点管理和数据热点等挑战，但一致性哈希在分布式缓存、存储、负载均衡等领域的广泛应用，已经证明了它的重要性。随着技术的发展，一致性哈希算法有望进一步优化，提升其在更复杂分布式环境下的适应能力。&lt;/p></description></item><item><title>分布式锁的实现原理与方式详解</title><link>https://cyber-blog.github.io/p/distributed-lock/</link><pubDate>Sat, 07 Jun 2025 00:00:00 +0000</pubDate><author>majiang213@foxmail.com (majiang)</author><guid>https://cyber-blog.github.io/p/distributed-lock/</guid><description>&lt;h1 id="分布式锁的实现原理与方式详解">分布式锁的实现原理与方式详解
&lt;/h1>&lt;h2 id="一基于-redis-的分布式锁实现">一、基于 Redis 的分布式锁实现
&lt;/h2>&lt;p>Redis 是目前使用最广泛的分布式锁方案之一，通常通过如下命令实现：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">SET lock_key unique_id NX PX &lt;span class="m">30000&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="参数说明">参数说明
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>&lt;code>lock_key&lt;/code>：&lt;strong>键（Key）&lt;/strong>，表示分布式锁在 Redis 中的标识名；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>unique_id&lt;/code>：&lt;strong>值（Value）&lt;/strong>，代表当前请求加锁的客户端唯一标识（例如 UUID + ThreadID），用于确保释放锁时身份验证；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>NX&lt;/code>：表示仅在键不存在时才进行设置，防止覆盖其他客户端已持有的锁；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>PX 30000&lt;/code>：设置键的过期时间为 30 秒，防止因客户端异常退出而产生死锁。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="加锁失败的返回值">加锁失败的返回值
&lt;/h3>&lt;p>如果 &lt;code>lock_key&lt;/code> 已存在，说明已有其他线程持有锁，命令将返回 &lt;code>null&lt;/code>，表示加锁失败。&lt;/p>
&lt;h3 id="解锁-lua-脚本示例">解锁 Lua 脚本示例
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-lua" data-lang="lua">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">if&lt;/span> &lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">KEYS&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">ARGV&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="kr">then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">return&lt;/span> &lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;del&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">KEYS&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">return&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>该脚本判断当前请求者是否为锁的持有者（通过比对 &lt;code>unique_id&lt;/code>），只有持有者才能安全释放锁。&lt;/p>
&lt;hr>
&lt;h2 id="二基于-redisson-的分布式锁实现">二、基于 Redisson 的分布式锁实现
&lt;/h2>&lt;p>Redisson 是 Redis 官方推荐的 Java 客户端之一，封装了丰富的分布式对象，其中对分布式锁的支持较为完整。&lt;/p>
&lt;h3 id="主要特性">主要特性
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>支持可重入锁（同一线程可多次加锁）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Watchdog 自动续期机制，防止锁自动过期；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Lua 脚本保障操作原子性；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>支持公平锁、读写锁、联锁等高级功能。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="加锁-lua-脚本">加锁 Lua 脚本
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-lua" data-lang="lua">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;exists&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">KEYS&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kr">then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;hset&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">KEYS&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">ARGV&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;pexpire&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">KEYS&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">ARGV&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">return&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">end&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;hexists&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">KEYS&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">ARGV&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kr">then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;hincrby&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">KEYS&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">ARGV&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;pexpire&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">KEYS&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">ARGV&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">return&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">end&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">return&lt;/span> &lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;pttl&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">KEYS&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>
&lt;p>使用 Hash 存储锁持有者及重入次数；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ARGV[2]&lt;/code> 为唯一标识（如线程 ID）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若当前线程已持有锁，则重入计数 +1 并续期。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="解锁-lua-脚本">解锁 Lua 脚本
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-lua" data-lang="lua">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;hexists&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">KEYS&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">ARGV&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kr">then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">return&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">end&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">local&lt;/span> &lt;span class="n">counter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;hincrby&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">KEYS&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">ARGV&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">counter&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kr">then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;pexpire&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">KEYS&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">ARGV&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;del&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">KEYS&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">end&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>
&lt;p>减少持有者的重入计数；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若减为 0，释放锁。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="watchdog-自动续期机制">Watchdog 自动续期机制
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>默认锁的 TTL 为 30 秒；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若未显式设置 TTL，Redisson 会启动“看门狗”线程，每隔 10 秒自动续期，直至业务逻辑完成；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>避免因执行时间较长导致锁意外过期。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="java-使用示例">Java 使用示例
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">RLock&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">redissonClient&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getLock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;myLock&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">tryLock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">30&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TimeUnit&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">SECONDS&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 执行业务逻辑&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">finally&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">isHeldByCurrentThread&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">unlock&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三lua-脚本为何具备原子性">三、Lua 脚本为何具备原子性？
&lt;/h2>&lt;h3 id="核心机制">核心机制
&lt;/h3>&lt;p>Redis 执行 Lua 脚本时具备以下特性：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Redis 使用单线程模型；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>EVAL&lt;/code> 命令整体作为一个事务执行；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行脚本期间不会响应其他客户端请求；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>脚本内部多个 Redis 命令会被整体提交执行，无法被打断。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>因此，在 Redis 中执行 Lua 脚本具有天然的原子性，能够有效避免竞态条件。&lt;/p>
&lt;hr>
&lt;h2 id="四分布式锁的其他实现方式">四、分布式锁的其他实现方式
&lt;/h2>&lt;h3 id="1-基于数据库如-mysqlpostgresql">1. 基于数据库（如 MySQL/PostgreSQL）
&lt;/h3>&lt;h4 id="实现方式">实现方式
&lt;/h4>&lt;ul>
&lt;li>
&lt;p>利用唯一约束：&lt;code>INSERT INTO lock_table (key) VALUES ('lockKey')&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>或使用悲观锁：&lt;code>SELECT ... FOR UPDATE&lt;/code>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="优缺点">优缺点
&lt;/h4>&lt;ul>
&lt;li>
&lt;p>&lt;strong>优点&lt;/strong>：实现简单、依赖较少、与业务数据库一致性强；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>缺点&lt;/strong>：性能较差，不适合高并发场景，可能引发死锁或阻塞。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="2-基于-zookeeper-的分布式锁">2. 基于 ZooKeeper 的分布式锁
&lt;/h3>&lt;h4 id="实现方式-1">实现方式
&lt;/h4>&lt;ul>
&lt;li>
&lt;p>利用临时顺序节点（&lt;code>Ephemeral Sequential&lt;/code>）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有客户端在某节点下创建顺序子节点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>排序最小的节点获得锁，其他客户端监听前一个节点。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="优缺点-1">优缺点
&lt;/h4>&lt;ul>
&lt;li>
&lt;p>&lt;strong>优点&lt;/strong>：可靠性高、天然支持顺序和事件通知机制；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>缺点&lt;/strong>：部署复杂、性能受限于 ZooKeeper 的吞吐能力。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="3-基于-etcd-的分布式锁">3. 基于 Etcd 的分布式锁
&lt;/h3>&lt;h4 id="实现方式-2">实现方式
&lt;/h4>&lt;ul>
&lt;li>
&lt;p>利用 Etcd 的租约（Lease）和事务（Txn）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>客户端通过 CAS 机制创建唯一锁键，并绑定租约；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>续期机制保障锁的持有。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="优缺点-2">优缺点
&lt;/h4>&lt;ul>
&lt;li>
&lt;p>&lt;strong>优点&lt;/strong>：一致性强、适用于容器编排等场景；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>缺点&lt;/strong>：相对复杂，需要管理租约续期和连接状态。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="五小结">五、小结
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>实现方式&lt;/th>
&lt;th>优点&lt;/th>
&lt;th>缺点&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Redis&lt;/td>
&lt;td>高性能、实现简单、生态丰富&lt;/td>
&lt;td>容易出现锁失效或误删&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Redisson&lt;/td>
&lt;td>功能丰富、支持自动续期&lt;/td>
&lt;td>相对重量级，需客户端支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>数据库&lt;/td>
&lt;td>简单易用、无需引入中间件&lt;/td>
&lt;td>性能瓶颈明显，存在死锁风险&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ZooKeeper&lt;/td>
&lt;td>高可靠性、顺序性好&lt;/td>
&lt;td>部署复杂、性能有限&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Etcd&lt;/td>
&lt;td>一致性强、支持租约机制&lt;/td>
&lt;td>运维成本高，使用门槛较高&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>选择分布式锁实现方案时，应根据系统性能需求、可靠性要求和技术栈综合考虑。&lt;/p></description></item></channel></rss>