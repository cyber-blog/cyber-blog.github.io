<!doctype html><html lang=zh-ch dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="主要从执行流程、覆盖索引、回表与索引下推这几个方面讲"><title>MySQL InnoDB 索引机制与优化</title>
<link rel=canonical href=https://cyber-blog.github.io/p/database-index/><link rel=stylesheet href=/scss/style.min.70a01615b5dd99826a360296920067f6e3896a41fe397d04d6b849efef75a174.css><meta property='og:title' content="MySQL InnoDB 索引机制与优化"><meta property='og:description' content="主要从执行流程、覆盖索引、回表与索引下推这几个方面讲"><meta property='og:url' content='https://cyber-blog.github.io/p/database-index/'><meta property='og:site_name' content='仿生人会梦见电子羊吗？'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='MYSQL'><meta property='article:published_time' content='2025-08-04T00:00:00+00:00'><meta property='article:modified_time' content='2025-08-04T00:00:00+00:00'><meta name=twitter:title content="MySQL InnoDB 索引机制与优化"><meta name=twitter:description content="主要从执行流程、覆盖索引、回表与索引下推这几个方面讲"><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu9062387157319251782.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🫥</span></figure><div class=site-meta><h1 class=site-name><a href=/>仿生人会梦见电子羊吗？</a></h1><h2 class=site-description>Do Androids Dream of Electric Sheep?</h2></div></header><ol class=menu-social><li><a href=https://github.com/majiang213 target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#innodb-索引查找与执行流程><strong>InnoDB 索引查找与执行流程</strong></a></li><li><a href=#覆盖索引与回表对比><strong>覆盖索引与回表对比</strong></a></li><li><a href=#索引条件下推icp的作用与使用><strong>索引条件下推（ICP）的作用与使用</strong></a></li><li><a href=#索引相关概念对比一览><strong>索引相关概念对比一览</strong></a></li><li><a href=#实战优化建议best-practices><strong>实战优化建议（Best Practices）</strong></a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/tech/ style=background-color:#2a9d8f;color:#fff>技术博客</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/database-index/>MySQL InnoDB 索引机制与优化</a></h2><h3 class=article-subtitle>主要从执行流程、覆盖索引、回表与索引下推这几个方面讲</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Aug 04, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 9 分钟</time></div></footer></div></header><section class=article-content><h1 id=mysql-innodb-索引机制与优化执行流程覆盖索引回表与索引下推>MySQL InnoDB 索引机制与优化：执行流程、覆盖索引、回表与索引下推</h1><p>InnoDB 表基于 B+ 树实现<strong>聚簇索引</strong>（主键）和多个<strong>二级索引</strong>。查询时，MySQL 优化器会选择合适的索引，然后按照执行流程依次进行索引查找（检索满足条件的索引项）、条件过滤、排序（如有需要）和<strong>回表</strong>（根据二级索引叶子节点的主键值检索完整行）。如果所有查询列都包含在索引中（覆盖索引），则可避免回表，从而节省随机 IO ；否则需要通过主键到聚簇索引检索整行数据（回表），这增加了额外开销 。此外，InnoDB 支持<strong>索引条件下推</strong>（Index Condition Pushdown，ICP）优化：在扫描二级索引时，将部分 WHERE 条件在存储引擎层提前过滤，从而减少了无效行的回表次数 。</p><p>以下内容通过实际建表、查询示例和 EXPLAIN 分析，详细阐述索引在各阶段的作用，比较覆盖索引与回表的差异，并说明 ICP 在执行流程中的作用与限制。</p><h2 id=innodb-索引查找与执行流程><strong>InnoDB 索引查找与执行流程</strong></h2><p>MySQL 查询经过优化器确定执行计划，若使用索引，则执行引擎依次进行：<strong>(1) 索引查找</strong>：根据索引 B+ 树定位满足前缀条件的叶子节点；<strong>(2) 条件过滤</strong>：对于索引未能覆盖的条件，在存储引擎层过滤（ICP 可提前过滤部分条件），其余条件或计算在服务器层过滤；<strong>(3) 排序</strong>：若 ORDER BY 条件与索引顺序一致，则可以顺序扫描索引避免额外排序；否则会使用额外的排序（Using filesort） ；<strong>(4) 回表</strong>：如果查询需要的列不全在二级索引中，则根据索引叶子节点的主键值到聚簇索引查完整行，此过程即“回表”。整个流程如下：</p><ul><li><strong>索引查找</strong>：优化器选择最合适的索引（如单列索引、多列联合索引）进行查找。InnoDB 二级索引叶子节点存储了对应行的主键值 ，因此定位二级索引时可直接获取主键。</li><li><strong>条件过滤</strong>：默认情况下，MySQL 服务器层将所有非索引列的过滤条件留到获取完整行后处理；对于索引列上的条件，存储引擎可在索引层过滤。启用 ICP 时，满足条件的行可以在索引层提前淘汰 。</li><li><strong>排序</strong>：如果查询涉及 ORDER BY，优化器检查索引顺序是否可以按需排序。若索引前缀完全匹配排序列并且无其他排序列，则无需额外排序；否则会产生 Using filesort 。</li><li><strong>回表（Bookmark Lookup）</strong>：当查询列超出索引范围时，需要回表。InnoDB 的二级索引只能快速定位主键值，故若查询还需其他列数据，就要通过主键到聚簇索引读取完整行，这就是回表过程 。</li></ul><p>综上，优化索引以让查询满足覆盖索引条件，可避免回表，提高效率 ；否则回表成为瓶颈。我们下面通过示例演示这两种情况。</p><h2 id=覆盖索引与回表对比><strong>覆盖索引与回表对比</strong></h2><ul><li><strong>覆盖索引</strong>：若查询的所有列都包含在一个索引中（包括二级索引列及隐含的主键列），则查询可以完全从索引读取所需数据，无需访问表数据 。EXPLAIN 中 Extra 字段会显示 Using index 。这意味着 MySQL 引擎使用索引即可得到结果，无须读取表行。</li><li><strong>回表</strong>：若查询涉及的列不全在索引中，则即使可以使用索引检索行主键，也必须通过主键到聚簇索引读出其余列，这称为回表。回表需要额外的随机 I/O 和时间 ，性能低于纯索引扫描。</li></ul><p>我们以实际例子说明。假设有如下表和索引：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>demo</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>name</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>20</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>dept</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>20</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>salary</span><span class=w> </span><span class=nb>INT</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>age</span><span class=w> </span><span class=nb>INT</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_name_dept</span><span class=w> </span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>dept</span><span class=p>,</span><span class=w> </span><span class=n>salary</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=n>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li><strong>回表示例</strong>：查询非覆盖情况需要回表。比如查询 name=&mldr;、dept=&mldr; 和 age（未加索引列）：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>dept</span><span class=p>,</span><span class=w> </span><span class=n>age</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>demo</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>name</span><span class=o>=</span><span class=s1>&#39;Alice&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>dept</span><span class=o>=</span><span class=s1>&#39;Sales&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>说明：索引 idx_name_dept(name,dept,salary) 可以用于查找符合 name 和 dept 的行，但列 age 不在索引中，因此每匹配到一条记录后，需要通过主键 id 回表读取 age。对应的执行计划可能如下（示例）：</p><div class=table-wrapper><table><thead><tr><th><strong>id</strong></th><th><strong>select_type</strong></th><th><strong>table</strong></th><th><strong>type</strong></th><th><strong>possible_keys</strong></th><th><strong>key</strong></th><th><strong>key_len</strong></th><th><strong>ref</strong></th><th><strong>rows</strong></th><th><strong>Extra</strong></th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>demo</td><td>ref</td><td>idx_name_dept</td><td>idx_name_dept</td><td>256</td><td>const,const</td><td>10</td><td>Using where</td></tr></tbody></table></div><ul><li><strong>解释</strong>：type=ref 表示用二级索引范围查找；key=idx_name_dept；Extra 显示 Using where，表明服务器层需要再执行 WHERE 条件过滤（尽管在此例中过滤完毕后还需回表检索列）。注意由于 age 不在索引中，这不是覆盖索引查询，因此 MySQL 会回表获取完整行才能返回 age。回表导致额外开销 。</li><li><strong>覆盖索引示例</strong>：若查询列都在索引中，则不回表。继续上述表结构，如果查询只取 salary：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>dept</span><span class=p>,</span><span class=w> </span><span class=n>salary</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>demo</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>name</span><span class=o>=</span><span class=s1>&#39;Alice&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>dept</span><span class=o>=</span><span class=s1>&#39;Sales&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>因为 name, dept, salary 恰好是索引 idx_name_dept 的列，且 id（主键）会隐式包含在每个索引叶子节点中，故此查询的所有列（name, dept, salary 及聚簇主键 id）均可从索引中取得，无须回表。执行计划示例：</p><div class=table-wrapper><table><thead><tr><th><strong>id</strong></th><th><strong>select_type</strong></th><th><strong>table</strong></th><th><strong>type</strong></th><th><strong>possible_keys</strong></th><th><strong>key</strong></th><th><strong>key_len</strong></th><th><strong>ref</strong></th><th><strong>rows</strong></th><th><strong>Extra</strong></th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>demo</td><td>ref</td><td>idx_name_dept</td><td>idx_name_dept</td><td>256</td><td>const,const</td><td>5</td><td>Using index</td></tr></tbody></table></div><ul><li><strong>解释</strong>：Extra 显示 Using index ，表示此查询可以由索引覆盖执行，不需要访问表（所谓覆盖索引）。通过覆盖索引，避免了读聚簇索引的随机 I/O ，查询效率更高。</li></ul><p>下表总结覆盖索引与回表的区别：</p><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>覆盖索引</strong></th><th><strong>回表</strong></th></tr></thead><tbody><tr><td>列需求</td><td>查询列完全包含在索引中（加上主键列）</td><td>查询列不全在索引中</td></tr><tr><td>I/O 行为</td><td>直接从索引树读取数据，无需访问表</td><td>需要先查索引取主键值，再到聚簇索引读行</td></tr><tr><td>EXPLAIN Extra</td><td>Using index</td><td>通常含 Using where（或 Using index condition）</td></tr><tr><td>性能</td><td>最优（避免额外随机 I/O）</td><td>较差（额外随机 I/O 和 CPU 过滤开销）</td></tr><tr><td>适用场景</td><td>查询列固定且已编入索引；WHERE/GROUP BY/ORDER BY 列索引前缀</td><td>查询列超出索引；无覆盖索引需补列数据</td></tr></tbody></table></div><p>以上示例说明：构造合理的联合索引，尽量让查询成为覆盖索引（如将常用的过滤列和返回列包含进索引），可以显著提高查询性能 。</p><h2 id=索引条件下推icp的作用与使用><strong>索引条件下推（ICP）的作用与使用</strong></h2><p>**索引条件下推（Index Condition Pushdown, ICP）**是 MySQL 5.6+ 为 InnoDB 和 MyISAM 二级索引设计的优化功能 。当使用二级索引检索行时，如果查询中存在多个条件，其中只有部分条件能利用索引列，则 MySQL 默认会把满足索引的那部分条件下推到存储引擎中进行过滤，减少回表次数 。具体行为如下：</p><ol><li><strong>无 ICP 时</strong>：存储引擎按索引查到每一行对应的主键值并回表，然后服务器层再对返回的行执行全部剩余的 WHERE 条件过滤 。这意味着即使某些条件可在索引层判断，也要等回表后才能筛选，导致大量不必要的行读取。</li><li><strong>启用 ICP 后</strong>：存储引擎在扫描索引时，将能够在索引列上判断的条件提前执行：<strong>只有在索引条件也满足的情况下，才回表读取该行</strong> 。对于索引层无法判断（非索引列或函数列）的条件，待回表后再在服务器层过滤。</li></ol><p>举例说明：继续上述 demo 表，如果我们对 idx_name_dept(name,dept,salary) 既有索引，又对列 age 没有索引，则考虑如下查询：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>dept</span><span class=p>,</span><span class=w> </span><span class=n>salary</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>demo</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>name</span><span class=o>=</span><span class=s1>&#39;Alice&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>salary</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>50000</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mi>30</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>索引 idx_name_dept 可用于 name=&lsquo;Alice&rsquo;（精确匹配）和 salary > 50000（范围匹配），但 age &lt; 30 无索引参与。启用 ICP 时，存储引擎会首先根据 name 和 salary 在索引上查找主键，然后在索引层判断 age &lt; 30 条件。如果 age 不在索引中，就不能在索引层判断，所以 age &lt; 30 在索引层跳过，而在回表后由服务器层执行。</li><li>EXPLAIN 输出示例可能为：</li></ul><div class=table-wrapper><table><thead><tr><th><strong>id</strong></th><th><strong>select_type</strong></th><th><strong>table</strong></th><th><strong>type</strong></th><th><strong>possible_keys</strong></th><th><strong>key</strong></th><th><strong>key_len</strong></th><th><strong>ref</strong></th><th><strong>rows</strong></th><th><strong>Extra</strong></th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>demo</td><td>range</td><td>idx_name_dept</td><td>idx_name_dept</td><td>258</td><td>const,const</td><td>15</td><td>Using index condition</td></tr></tbody></table></div><p>这里 Extra 显示 Using index condition ，意味着 ICP 被使用。根据官方文档：“Using index condition 说明索引条件下推已经生效 ”。此时 MySQL 引擎会先在索引层应用 name=&lsquo;Alice&rsquo; AND salary>50000 过滤匹配的行，只有满足这些条件的索引条目才会被读取主键，回表到主表后服务器再检查 age&lt;30。由此避免了对不满足前两条件的行进行回表，从而降低了 I/O 和 CPU 开销 。如果关闭 ICP（例如执行 SET optimizer_switch=&lsquo;index_condition_pushdown=off&rsquo;;），则 EXPLAIN 中 Extra 只会显示 Using where ，意味着索引层只用 name=&lsquo;Alice&rsquo; 等定位，查询返回的所有行都要回表并在服务器层再做 age&lt;30 筛选，效率较低。</p><p>需要注意的是，<strong>ICP 只对二级索引有效</strong> 。InnoDB 的聚簇主键检索时，整行已经加载到缓冲区，故对主键索引应用 ICP 无意义。ICP 条件要求如文档所述：访问方法为 range/ref/eq_ref/ref_or_null，且表需要访问完整行 。此外，ICP 不能下推子查询和存储函数等复杂条件 。</p><p>以下示例演示 ICP 在 EXPLAIN 输出中的表现：假设 demo 表中数据足够多，我们执行上面查询（启用 ICP）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 启用ICP（默认开启），执行查询
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>dept</span><span class=p>,</span><span class=w> </span><span class=n>salary</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>demo</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>name</span><span class=o>=</span><span class=s1>&#39;Alice&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>salary</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>50000</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mi>30</span><span class=err>\</span><span class=k>G</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>执行计划解析（示例）：</p><ul><li>key=idx_name_dept：使用复合索引。</li><li>type=range：范围查找（因为对 salary > 50000）。</li><li>Extra=Using index condition ：说明引擎在索引层先应用了 name 和 salary 条件过滤，后续再回表检查 age 条件。</li></ul><p>总结：ICP 在执行流程中的位置在<strong>索引查找后、回表前</strong>，能有效减少回表次数 。在 EXPLAIN 输出中，Using index condition 表示 ICP 生效；若额外出现 Using where，说明仍有非索引列的过滤条件需在服务器层处理 。例如上例的 age&lt;30 就因未在索引而留在服务器层。</p><h2 id=索引相关概念对比一览><strong>索引相关概念对比一览</strong></h2><p>下表对照了本文讨论的关键概念及其适用场景：</p><div class=table-wrapper><table><thead><tr><th><strong>概念</strong></th><th><strong>触发条件</strong></th><th><strong>优势</strong></th><th><strong>EXPLAIN 标志</strong></th></tr></thead><tbody><tr><td><strong>覆盖索引</strong></td><td>查询所需列全包含在某索引（包括主键）</td><td>避免回表，减少随机 IO，提高查询效率</td><td>Using index</td></tr><tr><td><strong>回表</strong></td><td>查询列超出所用索引时</td><td>无</td><td>Using where（无 Using index）</td></tr><tr><td><strong>索引下推 (ICP)</strong></td><td>复合索引扫描时，有部分条件非索引列</td><td>索引层提前过滤，减少回表次数</td><td>Using index condition</td></tr><tr><td><strong>排序 (filesort)</strong></td><td>ORDER BY 列未按索引顺序（或无合适索引）</td><td>数据量小或内存足够时开销可接受，小表也可忽略</td><td>Using filesort</td></tr></tbody></table></div><p>表中各项分别对应覆盖索引利用索引免回表的优势 ；回表的触发（非覆盖）场景；ICP 适用情况与好处 ；以及排序相关的指标 Using filesort 表示排序在内存或外部进行 。</p><h2 id=实战优化建议best-practices><strong>实战优化建议（Best Practices）</strong></h2><ul><li><strong>设计覆盖索引</strong>：分析业务查询，针对常见的 WHERE、GROUP BY、ORDER BY 和 SELECT 列，设计联合索引，使其尽量覆盖这些查询。覆盖索引能大幅减少随机读，从而提速 。</li><li><strong>注意索引列顺序</strong>：联合索引中将筛选条件最常用的列放在最左侧；只有左前缀匹配才能有效使用索引。复合索引建列顺序应符合查询逻辑，切勿盲目多列索引 。</li><li><strong>合理限制 SELECT 列</strong>：避免 SELECT *，只选取必要列。若查询返回较少列，能降低回表概率，或可让索引覆盖更多查询需求 。</li><li><strong>利用 EXPLAIN 分析执行计划</strong>：定期检查慢查询或关键查询的 EXPLAIN 输出，关注 type、key、rows、Extra 等字段。若出现 Using filesort 或全表扫描（type=ALL）等提示，要考虑创建索引或调整查询逻辑。</li><li><strong>启用 ICP（默认开启）</strong>：对于范围查询或多条件过滤，EXPLAIN 出现 Using index condition 时说明 ICP 正在减少回表。确认 MySQL 版本 ≥5.6，保持 optimizer_switch 中 index_condition_pushdown 为 on。注意ICP只对二级索引生效 。</li><li><strong>监控主键设计</strong>：主键越长，二级索引叶子节点也会越大（因为每条叶子记录都要存储主键），影响缓存命中和 I/O。避免在高频使用的表上构建过长的主键 。</li><li><strong>定期统计与优化</strong>：使用 ANALYZE TABLE 保持统计信息准确，确保优化器能正确估算成本。对极少更新的大表，可考虑手动分析。采用 OPTIMIZE TABLE 或在线重建表，以消除碎片、缩减数据页。</li></ul><p>通过上述策略，配合对 EXPLAIN 输出的深入理解 和指标观察，可最大化发挥 InnoDB 索引的性能优势，避免不必要的回表和排序开销，从而优化查询性能。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/mysql/>MYSQL</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/mysql-%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B/><div class=article-details><h2 class=article-title>Mysql 查询流程</h2></div></a></article><article><a href=/p/mvcc%E6%80%BB%E7%BB%93/><div class=article-details><h2 class=article-title>MVCC总结</h2></div></a></article><article><a href=/p/spring-boot/><div class=article-details><h2 class=article-title>Spring Boot应用假死现象：SLF4J日志框架冲突深度分析</h2></div></a></article><article><a href=/p/jmm/><div class=article-details><h2 class=article-title>JMM</h2></div></a></article><article><a href=/p/consistent-hash/><div class=article-details><h2 class=article-title>一致性哈希的简单介绍</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//majiang.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 仿生人会梦见电子羊吗？</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>